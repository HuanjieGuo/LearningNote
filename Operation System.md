# 第一章 

## 概念

### 操作系统的特征

**并发性和共享性互为存在条件**

- 并发

  并发：宏观同时发生，微观交替发生。

  并行：多个事件同一时刻同时发生。

- 共享

  - 互斥共享方式 

    一个时间段内只允许一个进程访问该资源

    eg. 使用QQ和微信视频。同一时间下只能分配给一个。

  - 同时共享方式

    允许一个时间段内由多个进程“同时”对它们进行访问

    eg. 使用QQ和微信发文件，宏观上同时发送，两个进程都在访问磁盘资源。微观上，两个进程是交替着访问硬盘的。

- 虚拟

  - 空分复用技术 (如虚拟存储器技术)
  - 时分复用技术 (如虚拟处理器)

- 异步



### OS发展历史

**手工操作阶段**



**批处理阶段**

单道批处理

缺点：资源利用率低



多道批处理 (并发、共享)

类似流水线

![WeChat2b66bf3f9b5c1c3ff87d6c1479f662a3.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnhgzx36wmj31c810ke81.jpg)



主要缺点： 用户相应时间长，没有人机交互



**分时操作系统**

计算机以时间片为单位轮流为各个用户/作业服务。

主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。

缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的。



**实时操作系统**

优点：优先响应一些紧急任务，某些紧急任务不需时间片排队。



在实时操作系统下，计算机接收到外部信号后及时进行处理，并且要在严格时限内处理完事件。 实时操作系统的主要特点是及时性和可靠性。

- 硬实时系统

  必须在绝对严格的规定时间内完成处理

- 软实时系统

  能接受偶尔违反时间规定



### OS的运行机制和体系结构

#### 运行机制

**两种指令**

指令：处理器(CPU)能识别、执行的最基本命令

- 特权指令

  如内存清零指令（不允许用户线程使用）

- 非特权指令

  如普通的运算指令



CPU如何判断当前是否可以执行特权指令？

**两种处理器状态**

- 用户态（目态）

  只能执行非特权指令

- 核心态（管态）

  能执行特权指令和非特权指令



**两种程序**

- 内核程序

  系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。

- 应用程序

  只能执行非特权指令，运行在用户态



![WeChat3514c2c2ec0e7d9a6a9130ec744d4366.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnhhmr82ttj31ts0nkb29.jpg)

内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。

实现操作系统内核功能的程序就是内核程序。



#### **操作系统内核**

时钟管理，中断处理，原语  是与硬件关联较密切的模块  

- 时钟管理

  实现计时功能。

- 中断处理

  负责实现中断机制

- 原语

  - 是一种特殊的程序
  - 处于操作系统最底层，是最接近硬件的部分
  - 这种查询运行具有原子性，不能被中断
  - 运行时间较短、调用频繁

- 对系统资源进行管理的功能(有些操作系统不把这部分归为“内核功能”)

  - 进程管理
  - 存储器管理
  - 设备管理





#### **操作系统体系结构**

- 大内核
  - 将操作系统的主要功能模块都作为系统内核，运行在核心态
  - 优点：高性能
  - 缺点：内核代码庞大，结构混乱，难以维护
- 微内核
  - 只把最基本的功能保留在内核
  - 优点：内核功能少，结构清晰，方便维护
  - 缺点：需要频繁在核心态和用户态之间**切换**，性能低



**大内核和微内核划分方式**

![WeChat1149c4e9e688a6c90f19dd5a02c2e45a.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnhhvn1no4j31r40wcb29.jpg)

------

### 中断和异常

#### 中断的概念和作用

1. 当中断发生时，CPU立即进入核心态
2. 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。
3. 对于不同的中断信号，会进行不同的处理。



中断可以使CPU从**用户态切换为核心态**，使操作系统获得计算机的控制权。



问题：用户态、核心态之间的切换是怎么实现的？

答：“用户态 -> 核心态” 通过中断实现。并且**中断**是**唯一途径**。

“核心态 -> 用户态” 通过执行一个**特权指令**，将程序状态字(PSW)的标志位设置为"用户态“。



#### 中断的分类

- 内中断 (也称为异常、例外、陷入)

  信号来源： CPU**内部**， 与当前执行指令有关

  - 自愿中断——指令中断

    如：系统调用时使用的访管指令(又叫陷入指令，trap指令)

  - 强迫中断

    - 硬件故障

      如缺页

    - 软件中断

      如整数除0

- 外中断 (中断)

  信号来源：CPU**外部**，与当前执行的指令无关

  - 外设请求

    如：I/O操作完成发出的中断信号

  - 人工干预

    如：用户强行终止一个进程



#### 外中断的处理过程

Step1: 执行完每个指令之后，CPU都要检查当前是否有外部中断信号。

Step2: 如果检测到外部中断信号，则需要保护被中断进程的CPU环境(如程序状态字PSW、程序计数器PC、各种通用寄存器)

Step3:根据中断信号类型转入相应的中断处理程序(此程序运行在核心态)

Step4:恢复原进程的CPU环境并退出中断，返回原进程继续往下执行。



------

### 系统调用

操作系统需要向上提供一些服务。主要包括**命令接口**和**程序接口**。其中，程序接口由一组**系统调用**组成。

应用程序通过**系统调用**请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的**稳定性和安全性**，防止用户进行非法操作。



#### 系统调用与库函数的区别

![WeChat174ba982f7c990ddb1f98f1955898331.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gni4zdiqusj31ju0m0hdt.jpg)



#### 系统调用背后过程

传递系统调用参数->执行陷入指令(用户态)->执行系统调用(核心态)->返回用户程序

本处陷入指令类似于汇编 int x 指令，int是interrupt的意思，x是系统调用对于操作的编号

注意：

1. **陷入指令**是在**用户态**执行的，执行完后立即引发一个**内中断**，从而CPU进入**核心态**。

2. 发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。
3. 陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。



# 第二章 

## 进程

系统为每个运行的程序配置一个数据结构，成为进程控制块(PCB),用来描述进程的各种信息。



### 进程的组成

**PCB、程序段、数据段**三部分构成了**进程实体**(进程映像)，一般情况下，我们把进程实体简称为进程，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。

注意：**PCB是进程存在的唯一标志**。



PCB：PCB包含操作系统对进程进行管理所需的各种信息。

程序段：程序代码

数据段：程序运行时产生的运算数据。如全局变量、局部变量。

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnikr63n4cj30e40ua7js.jpg" alt="WeChat9cc089557c4b3423303143f924e5d591.png" style="zoom: 33%;" />

**PCB结构**

- 进程描述信息

  - 进程标识符PID
  - 用户标识符UID

- 进程控制和管理信息

  - 进程当前状态
  - 进程优先级

- 资源分配清单

  - 程序段指针
  - 数据段指针
  - 键盘
  - 鼠标

- 处理机相关信息

  - 各种寄存器值

    进程切换时需要把当前运行情况记录下来保存在PCB中，如程序计数器的值表示当前程序执行到哪一句。保留中断发生时的状态。



进程是进程实体的**运行过程**，是系统进行**资源分配**和**调度**的一个独立单位。

------



### 进程的组织



**进程组织方式**

- 链接方式
  - 按照进程状态将PCB分为多个队列
  - 操作系统持有指向各个队列的指针
- 索引方式
  - 根据进程状态的不同，建立几张索引表
  - 操作系统持有指向各个索引表的指针



**链接方式**

![WeChatff01b87f8fa14fff3fb4332216df61b9.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnilbp6qcwj32du19ee83.jpg)



**索引方式**

![WeChat44f05f7783d77b14e4eb56ce751f247d.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnildksifjj31wm16yhdt.jpg)



------



### 进程的特性

- 动态性 (**最基本的特征**)

  进程是程序的一次执行过程，是动态地产生、变化和消亡的

- 并发性

  内存中有多个进程实体，各进程可并发执行

- 独立性

  进程是能够独立运行、独立**获得资源、独立接受调度的基本单位**

- 异步性

  各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题

- 结构性

  每个进程都会配置一个PCB。结构上看，进程由**程序段、数据段、PCB**组成



------

### 进程的状态及转换

**三种基本状态**

- 运行态(Running)  

  CPU ☑️   其它所需资源☑️

  占有CPU，并在CPU上运行

- 就绪态(Ready)

  CPU ❌   其它所需资源☑️

  具备运行条件，没有空闲CPU，而暂时不能运行

- 阻塞态(Waiting/Blocked,又称：等待态)

  CPU ❌   其它所需资源❌

  因为等待某一事件而暂时不能运行

  如等待操作系统分配打印机、等待读磁盘操作的结果。

**另外两种状态**

- 创建态(New,又称：新建态)

  进程正在被创建，操作系统为进程分配资源、初始化PCB

- 终止态(Terminated, 又称：结束态)

  进程正在从系统中撤销，操作系统回收进程拥有的资源、撤销PCB



**进程的转换**

![WeChatfa60b05e161d205ba6134e88342b33ed.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnim9vmd9ij31gm0qe7wi.jpg)



- 就绪态 -> 运行态

  进程被调度

- 运行态 -> 就绪态

  时间片到，或CPU被其它高优先级的进程抢占

- 运行态 -> 阻塞态

  等待系统资源分配，或者某事件发生(主动行为)

- 阻塞态 -> 就绪态

  资源分配到位，等待的时间发生(被动行为)

  

注意： 不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态 。

------

### 进程控制

进程控制就是实现进程状态转换。

用原语实现进程控制。原语的特点是执行期间**不允许中断**，具有**原子操作**。

原语的原子操作特性通过**关/开中断**来实现

原语时一种特殊的程序

#### 进程的创建

- 创建原语

  - 申请空白PCB
  - 为新进程分配所需资源
  - 初始化PCB
  - 将PCB插入就绪队列

- 引起进程创建事件

  - 用户登陆

    分时系统中，用户登陆成功，系统会为其建立一个新的进程

  - 作业调度

    多道批处理系统中，有新的作业放入内存时，会为其创建一个新的进程

  - 提供服务

    用户向操作系统提出某些请求时，会新建一个进程处理该请求

  - 应用请求

    由用户进程主动请求创建一个子进程



#### 进程的终止

-  撤销原语
  - 从PCB集合中找到终止进程的PCB
  - 若进程正在运行，立即剥夺CPU，将CPU分配给其它进程
  - 终止其所有子进程
  - 将该进程拥有的所有资源归还给父进程或操作系统
  - 删除PCB
- 引起进程终止的事件
  - 正常结束
  - 异常结束
  - 外界干预



#### 进程的阻塞

- 阻塞原语
  - 找到要阻塞的进程对应的PCB
  - 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行
  - 将PCB插入相应事件的等待队列
- 引起进程阻塞的事件
  - 需要等待系统分配某种资源
  - 需要等待互相合作的其它进程完成工作



#### 进程的唤醒

- 唤醒原语
  - 在事件等待队列中找到PCB
  - 将PCB从等待队列移除，设置进程为就绪态
  - 将PCB插入就绪队列，等待被调度
- 引起进程唤醒的事件
  - 等待的事件发生



#### 进程的切换

- 切换原语
  - 将运行环境信息存入PCB
  - PCB移入相应队列
  - 选择另一个进程执行，并更新其PCB
  - 根据PCB恢复新进程所需的运行环境
- 引起进程切换的事件
  - 当前进程时间片到
  - 有更高优先级的进程到达
  - 当前进程主动阻塞
  - 当前进程终止



------

### 进程通信

各进程拥有的内存地址空间**相互独立**。

为了保证安全，一个进程**不能直接访问**另一个进程的地址空间。

必须通过操作系统提供的方法进行通信



**进程通信**

- 共享存储
- 消息传递
- 管道通信



#### 共享存储

![WeChat25190c0ee4677886075dd4b53d7d5e8f.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gniot2j49dj311q0js7eu.jpg)

两个进程对共享空间的**访问**必须是**互斥**的(互斥访问通过操作系统提供的同步实现)

操作系统只负责提供共享空间和同步互斥工具(如P、V操作)



- 基于数据结构的共享

  比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种**低级通信**方式。

- 基于存储区的共享

  在内存中划出一块共享储存区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种**高级通信**方式。



#### 管道通信

![WeChatc0a5d4de8652a44c1d3263baa80bd1db.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnip0j9yx6j319s04qjxr.jpg)

“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。



1. 管道只能采用**半双工通信**，某一时间段内只能实现单向的传输。如果要实现**双向同时通信，则需要设置两个管道**。
2. 各进程需要**互斥**地访问管道。
3. 数据以字节流的形式写入管道，当**管道写满**时，**写进程**的write()系统调用将被**阻塞**，等待读进程将数据取走。当读进程将数据全部取走后，**管道变空**，此时**读进程**的read()系统调用将**被阻塞**。
4. 如果**没写满，就不允许读**。如果**没读空，就不允许写**。
5. 数据一旦被读出，就从管道中被抛弃，这意味着**读进程最多只能有一个**，否则可能会有读错数据的情况。



#### 消息传递

进程间的数据交换以**格式化的消息**(Message)为单位。进程通过操作系统提供的"发生消息/接收消息"两个**原语**进行数据交换。

![WeChat08f2e160ee3ff0e4ee83e7174f8ea6e7.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnipcufafjj30ra09eh0g.jpg)



- 直接通信方式

  消息直接挂在接收进程的消息缓冲队列上

  <img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnipfzmk9tj30k00d0aib.jpg" alt="WeChatf21f6deea963a261e089694852bbe961.png" style="zoom: 50%;" />

- 间接通信方式

  消息要先发送到中间实体中

  <img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnipictqr4j30rq094guq.jpg" alt="WeChat0b0f401850d9f3282bdeedd8a147b5d6.png" style="zoom: 50%;" />



------

### 线程

线程是一个**基本的CPU执行单元**，也是**程序执行流的最小单位**。

引入线程后，进程只作为**除CPU之外**的系统资源分配单元(打印机、内存地址空间等都是分配给进程的)。



#### 带来的变化

- 资源分配、调度
  - 传统进程机制中，进程是资源分配、调度的基本单位
  - 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
- 并发性
  - 传统进程机制中，只能进程间并发
  - 引入线程后，各线程间也能并发，提升了并发度
- 系统开销
  - 传统的进程间并发，需要切换进程的运行环境，系统开销很大
  - 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小
  - 引入线程后，并发所带来的系统开销减小



#### 线程的属性

- 线程是处理机调度的单位
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都有一个线程ID、线程控制块(TCB)
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间共享进程资源
- 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程的线程，系统开销很小
- 切换进程，系统开销很大



#### 线程的实现方式



- 用户级线程(User-Level Thread, ULT)

  用户线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责(包括线程切换)

  用户级线程中，线程切换可以在用户态下完成，无需操作系统干预。

  用户线程对用户不透明，对操作系统透明。

  ![WeChatd6dd2edb38ff6bf7c730724c8efa0dde.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqdv2c8dj30m20jmn76.jpg)

  

- 内核级线程(Kernel-Level Thread，KLT，又称"内核支持的线程")

  <img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqkztdn0j30ls0kodtb.jpg" alt="WeChatd4cb7c837b738f4978957a0d2a33cc9e.png" style="zoom:50%;" />

  内核级线程的**管理工作**由操作**系统内核**完成。线程调度、切换等工作都由内核负责，因此**内核级线程的切换**必须在**核心态**下才能完成。

  内核级线程是只有操作系统才能看到的线程。



在支持用户级线程和内核级的系统中，可以采用二者组合的方式：将n个用户级线程映射到m个内核级线程上(n>=m)

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqoegeraj30mq0lctnz.jpg" alt="WeChatcb6f7215e787ac34c73131d211c048ba.png" style="zoom:50%;" />

**重点**

操作系统只“看得见”内核级线程，因此只有**内核级线程才是处理机分配的单位**。



#### 多线程模型



##### 多对一模型

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqrql2o8j30mi0lc14x.jpg" alt="WeChat6c8d489393ec470ce7f546300260404e.png" style="zoom:50%;" />

多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被组设，并发度不高。多个线程**不可**在多核处理机上**并行**运行。



##### 一对一模型

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqw0herwj30o20le16s.jpg" alt="WeChat50c878add5cd1263d8cb814de119e5ac.png" style="zoom:50%;" />

一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。

缺点：一个用户进程占用多个内核级进程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。



##### 多对多模型

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnir0cae7qj30mm0lik7l.jpg" alt="WeChat2760e4681983ecdb5d4ad1d55262f473.png" style="zoom:50%;" />

n用户及线程映射到m个内核级线程(n>=m)。每个用户进程对应m个内核级线程。

优点：克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。



------

## 调度



**处理机调度**从就绪队列中按照一定的**算法**选择一个进程并**将处理机分配给它**运行。



### 调度的三个层次

#### 高级调度

高级调度(作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并**建立相应的进程(建立PCB)**，使它**获得竞争处理机的权利**。

高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。**作业调入时会建立相应的PCB，作业调出时才撤销PCB**。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。



#### 中级调度

引入虚拟存储技术之后，可将暂时不能运行的进程调至外存等待，等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是**提高内存利用率**和**系统吞吐量**。

暂时调到外存等待的进程状态为**挂起**状态。**PCB**并不会一起调到外存，而是会**常驻内存**。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到**挂起队列**中。



**中级调度**(内存调度),决定将哪个处于挂起状态的进程重新调入内存。

一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。



补充知识：**进程的挂起态与七状态模型**

暂时调到外存等待的进程状态为**挂起状态**(挂起态,suspend)

挂起态又可以进一步细分为**就绪挂起、阻塞挂起**两种状态

![WeChat66d8be1617f3e4a9a840e5c55b116c7b.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnit5ejyb1j32l410cu0y.jpg)

挂起和阻塞的区别，两种状态都是暂时不能获取CPU的服务，但挂起态是将进程映像调到外存区，而阻塞态下进程映像还在内存中。



#### 低级调度

**低级调度(进程调度)**，主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中**最基本的一种调度**。

进程调度的**频率很高**，一般几十毫秒一次。



#### 三个调度的联系、对比

|                    | 做什么                                                       | 调度发生在           | 发生频率 | 对进程状态的影响                  |
| ------------------ | ------------------------------------------------------------ | -------------------- | -------- | --------------------------------- |
| 高级调度(作业调度) | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存->内存(面向作业) | 最低     | 无->创建态->就绪态                |
| 中级调度(内存调度) | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存     | 外存->内存(面向进程) | 中等     | 挂起态->就绪态 (阻塞挂起->阻塞态) |
| 低级调度(进程调度) | 按照某种规则，从就绪队列中选择一个进程为其分配处理机         | 内存->CPU            | 最高     | 就绪态->运行态                    |

------

### 进程调度时机、切换与过程、方式



#### 时机

什么时候需要进行进程调度与切换？

- 当前运行的进程**主动放弃**处理机
  - 进程正常终止
  - 运行过程中发生异常而终止
  - 进程主动请求阻塞(如 等待I/O)
- 当前运行的进程**被动放弃**处理机
  - 分给进程的时间片用完
  - 有更紧急的事需要处理(如I/O中断)
  - 有更高优先级的进程进入就绪队列

什么时候不能进行进程调度与切换

- 在**处理中断的过程中**。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。
- 进程在**操作系统内核程序临界区**中
- 在**原子操作过程中**(原语)。原子操作不可中断。



临界资源：一个时间段只允许一个进程使用的资源。

临界区：访问临界资源的那段代码。

内核程序临界区一般是用来访问**某种内核数据结构**的，比如进程的就绪队列(又各就绪进程的PCB组成)



内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。

普通临界区访问临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。



#### 方式

**非剥夺调度方式**

非剥夺调度方式，又称**非抢占方式**。只允许进程主动放弃处理机。在运行过程中即使有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。

**剥夺调度方式**

剥夺调度方式，又称**抢占方式**。当一个进程正在处理机上执行时，如果有一个更重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给哪个更紧迫的进程。



#### 切换与过程

“狭义的进程调度“与”进程切换的区别“：

**狭义的进程调度**指的是从就绪队列中**选中一个要运行的进程**。(这个进程可以是刚刚被暂停执行的进程，也可能是**另一个进程**，后一种情况就需要**进程切换**)

**进程切换**是指一个进程让出处理机，由另一个进程占用处理机的过程。

**广义的进程调度**包含了选择一个进程和进程切换两个步骤。



进程的切换过程主要完成了：

1. 对原来运行进程各种数据的保存

2. 对新的进程各种数据的恢复

   (如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)

注意：**进程切换是由代价的**，因此如果过于频繁的进行进程调度、切换，会使整个系统的效率降低。



------

### 调度算法的评价指标

- CPU利用率

  利用率=忙碌时间/总时间

- 系统吞吐量

  单位时间内完成的作业数量

- 周转时间

  从作业被提交给系统，到作业完成的时间间隔

  - 周转时间、平均周转时间

  - 带权周转时间、平均带权周转时间

    带权周转时间 = 作业周转时间/作业实际运行时间

- 等待时间

  等待被服务的时间之和

- 响应时间

  从提交请求到首次产生响应所用的时间。

------

### 调度算法

#### 先来先服务(FCFS)

非抢占式算法



优点：公平、算法实现简单

缺点：排在长作业(进程)后面的短作业需要等待很长时间，对短作业来说用户体验不好。



FCFS算法**对长作业有利**，**对短作业不利**。



是否会导致**饥饿**(某进程/作业长期得不到服务) ： 不会



#### 短作业优先(SJF)

非抢占式算法

优点：短作业快速被执行

缺点：不公平

会导致饥饿(长时间得不到服务)、饿死(一直等不到服务)

#### 高响应比优先(HRRN)

响应比 = （等待时间+要求服务器时间）/ 要求服务时间

可以用于作业调度和进程调度

非抢占式算法

优点：综合考虑了等待时间和运行时间

等待时间相同时，要求服务时间短的优先(SJF的优点)

要求服务时间相同时，等待时间长的优先(FCFS优点)

不会导致饥饿

#### 时间片轮转(RR)

**抢占式**算法。 由时钟装置发出**时钟中断**来通知CPU时间片已到。

优点：公平；响应快，适用于分时操作系统；

缺点：由于高频率的进程切换，有一定系统开销；不区分紧急度

不会导致饥饿



#### 优先级调度

可以用于作业调度也可以用于进程调度。

非抢占式和抢占式都有



如何设置优先级

- 系统进程优先级高于用户进程

- 前台进程优先级高于后台进程

- 操作系统更偏好I/O 型进程(称I/O繁忙型进程)

  计算型进程(CPU繁忙型进程)

  I/O设备和CPU可以并行工作。优先让I/O繁忙型进程运行，越可能让I/O设置投入工作，资源利用率、系统吞吐量提升。



动态优先级

- 如果等待了很久，可以提高优先级
- 如果占用处理机很久，可以降低优先级
- 如果频繁I/O，可以提高优先级



优点：优先级区分紧急度，适用于实时操作系统。

缺点：可能导致低优先级作业的饥饿



#### 多级反馈队列调度

unix适用了本算法



结合各种算法优点

用于进程调度

抢占式算法

采用分级、不同时间片

优点：相对公平(FCFS优点); 每个新到达的进程都可以快速响应(RR优点);短进程只用较少时间可以完成(SPF优点);不必实现估计进程的运行时间；

会导致饥饿



## 进程同步、互斥

一个时间段内只允许一个进程使用的资源成为临界资源。临界资源需要互斥。



遵循原则

- 空闲让进

- 忙则等待

- 有限等待

  要在有限时间进入临界区，防止饥饿

- 让权等待

  进入不了临界区的进程，要释放处理机，防止忙等



### 进程互斥的软件实现方法

#### 单标志法

两个进程在**访问完临界区后**会把临界区的权限转交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予**。

```java
int turn = 0; //表示允许进入临界区的进程号
// P0进程
whlie(turn != 0); 	1
critical section;		2
turn = 1;						3  // 修改成1可以访问
remainder section; 	4  //剩余区
  

// P1进程
whlie(turn != 1); 	1
critical section;		2
turn = 0;						3  // 修改成0可以访问
remainder section; 	4  //剩余区
```

算法缺点， 顺序 P0->P1->P0->P1....

如果一开始标记位为0，P0不访问 P1也访问不了

**违背了“空闲让进”**



#### 双标志先检查法

```java
boolean flag[2];
flag[0] = false;
flag[1] = false; //开始设置两人都不想进

// P0进程
while(flag[1]);			1
flag[0] = true;			2
critical section;		3
flag[0] = false;		4
remainder section;

// P1进程
while(flag[0]);			5
flag[1] = true;			6
critical section;		7
flag[1] = false;		8
remainder section;
```

若按152637执行，P0和P1将同时访问临界区

**违背了“忙则等待”原则**。



#### 双标志后检查法

```java
boolean flag[2];
flag[0] = false;
flag[1] = false; //开始设置两人都不想进

// P0进程
flag[0] = true;			1
while(flag[1]);			2
critical section;		3
flag[0] = false;		4
remainder section;

// P1进程
flag[1] = true;			5
while(flag[0]);			6
critical section;		7
flag[1] = false;		8
remainder section;
```

按照1526的顺序执行，P0和P1都将无法进入临界区。

解决了“**忙着等待**”

违背了**“空闲让进”和“有限等待**”

各进程长期无法访问临界资源。



#### Peterson算法

孔融让梨

```java
boolean flag[2];
flag[0] = false;
flag[1] = false; //开始设置两人都不想进

int turn = 0; // turn 表示优先让哪个进入临界区

// P0进程
flag[0] = true;						1
turn = 1;									2
while(flag[1]&&turn==1);	3
critical section;					4
flag[0] = false;					5
remainder section;

// P1进程
flag[1] = true;						6
turn = 0;									7
while(flag[0]&&turn==0);	8
critical section;					9
flag[1] = false;					10
remainder section;
```

Peterson 算法违背了“让权等待”原则，会发生忙等。



### 进程互斥的硬件实现方法



#### 中断屏蔽方法

利用"开/关中断指令"实现(在某进程开始访问临界区到结束访问为止不允许被中断，也就不能发生进程切换，因此不可能发生两个同时访问临界区的情况)

```
关中断;
临界区;
开中断;
```

优点：简单、高效

缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令只能运行在内核态)



#### TestAndSet 指令

简称TS或TSL指令，TSL指令是**用硬件实现的**，执行的过程不允许被中断。S

```c
bool TestAndSet (bool *lock){
  bool old = *lock;
  *lock = true;
  return old;
}

while(TestAndSet(&lock)); // 上锁并检查
临界区代码段...
lock = false;   //"解锁"
剩余区代码段...
```

TSL指令把“检查”和“上锁”操作用硬件方式变成了原子操作。

优点：实现简单；适用于多处理机环境

缺点：不满足“让权等待”原则，忙等。



#### Swap指令

也称Exchange指令，或XCHG指令。

Swap指令是用硬件实现的，执行过程不允许被中断

```c
bool old = true;
while(old==true)
  	swap(&lock,&old);
临界区代码段...
lock = false;
剩余区代码段...
```

不满足“让权等待”



### 信号量机制

用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而方便的实现进程互斥、进程同步。

一对原语：**wait(S)**原语和**signal(S)**原语，简称为**P、V操作**。



#### 整型信号量

用一个整数型的变量作为信号量，用来表示**系统中某种资源的数量**。对信号量的操作只有三种，**初始化、P操作、V操作**。

整型信号量不满足“让权等待”，会发生忙等。

```java
int S = 1;
void wait(int S){ // wait原语
  while(S<=0);  // 忙等
  S=S-1;  		// 占用一个资源
}
void signal(int S){ //signal原语
  S=S+1; 			// 释放一个资源
}

// 进程P0
wait(S);			// 进入区， 申请资源
使用打印机;  	// 临界区 访问资源
signal(S);		// 退出区 释放资源
```

#### 记录型信号量

```c
typedef struct{
  int value;					//剩余资源数
  struct process *L;  // 等待队列
} semaphore;

void wait(semaphore S){
  S.value--;
  if(S.value<0){
    // block原语使进程从运行态进入阻塞态
    block (S.L);
  }
}

void signal(semaphore S){
  S.value++;
  if(S.value<=0){
    //wakeup原语唤醒等待队列中的一个进程，从阻塞态变为就绪态
    wakeup(S.L);
  }
}
```

**遵循“让权等待”**



### 信号量机制应用

#### 实现进程互斥

1. 分析并发过程的关键活动，划定临界区
2. 设置互斥信号量mutex，**初值为1**
3. 进入临界区之前执行P(mutex)
4. 在临界区之后执行V(mutex)

```c
semaphore mutex = 1;
P1(){
  P(mutex);
  临界代码段;
  V(mutex);
}
P2(){
  P(mutex);
  临界代码段;
  V(mutex);
}
```



#### 实现进程同步

1. 分析什么地方需要实现“同步关系”。
2. 设置同步信号量S，**初始值为0**
3. 在"前操作"之后执行V(S)
4. 在“后操作”之前执行P(S)

```java
semaphore S = 0;
P1(){
  代码1;
  代码2;
  V(S);
  代码3;
}
P2(){
  P(S);
  代码4;
  代码5;
  代码6;
}
// 4必须在1，2后才能执行
```



#### 实现进程的前驱关系

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnj4g4uchjj30ki0mgk2j.jpg" alt="WeChateb701e033ab20321a64b241e84b747d9.png" style="zoom:50%;" />

1. 为每一对前驱关系各设置一个同步变量
2. 在"前操作"之后对应的同步变量执行V(S)
3. 在“后操作”之前对应的同步变量执行P(S)

```c
P1(){
  S1;
  V(a);
  V(b);
}
P2(){
  P(a);
  S2;
  V(c);
  V(d);
}
P3(){
  P(b);
  S3;
  V(g);
}
P4(){
  P(c);
  S4;
  V(e);
}
P5(){
  P(d);
  S5;
  V(f);
}
P6(){
  P(e);
  P(f);
  P(g);
  S6;
}
```

### 生产者消费者问题

![WeChat095566ca1ba979b92e8dc8795dd71237.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnj4qbj4idj31ci0gg7kf.jpg)

缓冲区是临界资源，各进程必须**互斥**地访问。

缓冲区满时，生产者要等待消费者取走商品(**同步**)

缓冲区空时，消费者要等待生产者生产商品(**同步**)



```c
// 互斥信号量，实现缓冲区的互斥访问
semaphore mutex = 1;
// 同步信号量，表示空闲缓冲区的数量
semaphore empty = N;
// 同步信号量，表示产品的数量，也即非空缓冲区的数量。
semaphore full = 0;

producer(){
  生产一个产品;
  P(empty);
  P(mutex);
  把产品放入缓冲区;
  V(mutex);
  V(full);
}

consumer(){
  P(full);
  P(mutex);
  从缓冲区取走产品;
  V(mutex);
  V(empty);
  使用产品;
}

```

![WeChata0d8405bdd2add951832b71eee8d8c1b.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnj5qweo7hj30vw0ban8u.jpg)



**先同步，后互斥**。如果相反，可能造成死锁。

![WeChat5100a89ad65ab7e9f13be68bd87e42cf.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnj5jx10cwj31e60t84qq.jpg)



