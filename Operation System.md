# 第一章 

## 概念

### 操作系统的特征

**并发性和共享性互为存在条件**

- 并发

  并发：宏观同时发生，微观交替发生。

  并行：多个事件同一时刻同时发生。

- 共享

  - 互斥共享方式 

    一个时间段内只允许一个进程访问该资源

    eg. 使用QQ和微信视频。同一时间下只能分配给一个。

  - 同时共享方式

    允许一个时间段内由多个进程“同时”对它们进行访问

    eg. 使用QQ和微信发文件，宏观上同时发送，两个进程都在访问磁盘资源。微观上，两个进程是交替着访问硬盘的。

- 虚拟

  - 空分复用技术 (如虚拟存储器技术)
  - 时分复用技术 (如虚拟处理器)

- 异步



### OS发展历史

**手工操作阶段**



**批处理阶段**

单道批处理

缺点：资源利用率低



多道批处理 (并发、共享)

类似流水线

![WeChat2b66bf3f9b5c1c3ff87d6c1479f662a3.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnhgzx36wmj31c810ke81.jpg)



主要缺点： 用户相应时间长，没有人机交互



**分时操作系统**

计算机以时间片为单位轮流为各个用户/作业服务。

主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。

缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的。



**实时操作系统**

优点：优先响应一些紧急任务，某些紧急任务不需时间片排队。



在实时操作系统下，计算机接收到外部信号后及时进行处理，并且要在严格时限内处理完事件。 实时操作系统的主要特点是及时性和可靠性。

- 硬实时系统

  必须在绝对严格的规定时间内完成处理

- 软实时系统

  能接受偶尔违反时间规定



### OS的运行机制和体系结构

#### 运行机制

**两种指令**

指令：处理器(CPU)能识别、执行的最基本命令

- 特权指令

  如内存清零指令（不允许用户线程使用）

- 非特权指令

  如普通的运算指令



CPU如何判断当前是否可以执行特权指令？

**两种处理器状态**

- 用户态（目态）

  只能执行非特权指令

- 核心态（管态）

  能执行特权指令和非特权指令



**两种程序**

- 内核程序

  系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。

- 应用程序

  只能执行非特权指令，运行在用户态



![WeChat3514c2c2ec0e7d9a6a9130ec744d4366.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnhhmr82ttj31ts0nkb29.jpg)

内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。

实现操作系统内核功能的程序就是内核程序。



#### **操作系统内核**

时钟管理，中断处理，原语  是与硬件关联较密切的模块  

- 时钟管理

  实现计时功能。

- 中断处理

  负责实现中断机制

- 原语

  - 是一种特殊的程序
  - 处于操作系统最底层，是最接近硬件的部分
  - 这种查询运行具有原子性，不能被中断
  - 运行时间较短、调用频繁

- 对系统资源进行管理的功能(有些操作系统不把这部分归为“内核功能”)

  - 进程管理
  - 存储器管理
  - 设备管理





#### **操作系统体系结构**

- 大内核
  - 将操作系统的主要功能模块都作为系统内核，运行在核心态
  - 优点：高性能
  - 缺点：内核代码庞大，结构混乱，难以维护
- 微内核
  - 只把最基本的功能保留在内核
  - 优点：内核功能少，结构清晰，方便维护
  - 缺点：需要频繁在核心态和用户态之间**切换**，性能低



**大内核和微内核划分方式**

![WeChat1149c4e9e688a6c90f19dd5a02c2e45a.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnhhvn1no4j31r40wcb29.jpg)

------

### 中断和异常

#### 中断的概念和作用

1. 当中断发生时，CPU立即进入核心态
2. 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。
3. 对于不同的中断信号，会进行不同的处理。



中断可以使CPU从**用户态切换为核心态**，使操作系统获得计算机的控制权。



问题：用户态、核心态之间的切换是怎么实现的？

答：“用户态 -> 核心态” 通过中断实现。并且**中断**是**唯一途径**。

“核心态 -> 用户态” 通过执行一个**特权指令**，将程序状态字(PSW)的标志位设置为"用户态“。



#### 中断的分类

- 内中断 (也称为异常、例外、陷入)

  信号来源： CPU**内部**， 与当前执行指令有关

  - 自愿中断——指令中断

    如：系统调用时使用的访管指令(又叫陷入指令，trap指令)

  - 强迫中断

    - 硬件故障

      如缺页

    - 软件中断

      如整数除0

- 外中断 (中断)

  信号来源：CPU**外部**，与当前执行的指令无关

  - 外设请求

    如：I/O操作完成发出的中断信号

  - 人工干预

    如：用户强行终止一个进程



#### 外中断的处理过程

Step1: 执行完每个指令之后，CPU都要检查当前是否有外部中断信号。

Step2: 如果检测到外部中断信号，则需要保护被中断进程的CPU环境(如程序状态字PSW、程序计数器PC、各种通用寄存器)

Step3:根据中断信号类型转入相应的中断处理程序(此程序运行在核心态)

Step4:恢复原进程的CPU环境并退出中断，返回原进程继续往下执行。



------

### 系统调用

操作系统需要向上提供一些服务。主要包括**命令接口**和**程序接口**。其中，程序接口由一组**系统调用**组成。

应用程序通过**系统调用**请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的**稳定性和安全性**，防止用户进行非法操作。



#### 系统调用与库函数的区别

![WeChat174ba982f7c990ddb1f98f1955898331.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gni4zdiqusj31ju0m0hdt.jpg)



#### 系统调用背后过程

传递系统调用参数->执行陷入指令(用户态)->执行系统调用(核心态)->返回用户程序

本处陷入指令类似于汇编 int x 指令，int是interrupt的意思，x是系统调用对于操作的编号

注意：

1. **陷入指令**是在**用户态**执行的，执行完后立即引发一个**内中断**，从而CPU进入**核心态**。

2. 发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。
3. 陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。



# 第二章 

## 进程

系统为每个运行的程序配置一个数据结构，成为进程控制块(PCB),用来描述进程的各种信息。



### 进程的组成

**PCB、程序段、数据段**三部分构成了**进程实体**(进程映像)，一般情况下，我们把进程实体简称为进程，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。

注意：**PCB是进程存在的唯一标志**。



PCB：PCB包含操作系统对进程进行管理所需的各种信息。

程序段：程序代码

数据段：程序运行时产生的运算数据。如全局变量、局部变量。

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnikr63n4cj30e40ua7js.jpg" alt="WeChat9cc089557c4b3423303143f924e5d591.png" style="zoom: 33%;" />

**PCB结构**

- 进程描述信息

  - 进程标识符PID
  - 用户标识符UID

- 进程控制和管理信息

  - 进程当前状态
  - 进程优先级

- 资源分配清单

  - 程序段指针
  - 数据段指针
  - 键盘
  - 鼠标

- 处理机相关信息

  - 各种寄存器值

    进程切换时需要把当前运行情况记录下来保存在PCB中，如程序计数器的值表示当前程序执行到哪一句。保留中断发生时的状态。



进程是进程实体的**运行过程**，是系统进行**资源分配**和**调度**的一个独立单位。

------



### 进程的组织



**进程组织方式**

- 链接方式
  - 按照进程状态将PCB分为多个队列
  - 操作系统持有指向各个队列的指针
- 索引方式
  - 根据进程状态的不同，建立几张索引表
  - 操作系统持有指向各个索引表的指针



**链接方式**

![WeChatff01b87f8fa14fff3fb4332216df61b9.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnilbp6qcwj32du19ee83.jpg)



**索引方式**

![WeChat44f05f7783d77b14e4eb56ce751f247d.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnildksifjj31wm16yhdt.jpg)



------



### 进程的特性

- 动态性 (**最基本的特征**)

  进程是程序的一次执行过程，是动态地产生、变化和消亡的

- 并发性

  内存中有多个进程实体，各进程可并发执行

- 独立性

  进程是能够独立运行、独立**获得资源、独立接受调度的基本单位**

- 异步性

  各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题

- 结构性

  每个进程都会配置一个PCB。结构上看，进程由**程序段、数据段、PCB**组成



------

### 进程的状态及转换

**三种基本状态**

- 运行态(Running)  

  CPU ☑️   其它所需资源☑️

  占有CPU，并在CPU上运行

- 就绪态(Ready)

  CPU ❌   其它所需资源☑️

  具备运行条件，没有空闲CPU，而暂时不能运行

- 阻塞态(Waiting/Blocked,又称：等待态)

  CPU ❌   其它所需资源❌

  因为等待某一事件而暂时不能运行

  如等待操作系统分配打印机、等待读磁盘操作的结果。

**另外两种状态**

- 创建态(New,又称：新建态)

  进程正在被创建，操作系统为进程分配资源、初始化PCB

- 终止态(Terminated, 又称：结束态)

  进程正在从系统中撤销，操作系统回收进程拥有的资源、撤销PCB



**进程的转换**

![WeChatfa60b05e161d205ba6134e88342b33ed.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnim9vmd9ij31gm0qe7wi.jpg)



- 就绪态 -> 运行态

  进程被调度

- 运行态 -> 就绪态

  时间片到，或CPU被其它高优先级的进程抢占

- 运行态 -> 阻塞态

  等待系统资源分配，或者某事件发生(主动行为)

- 阻塞态 -> 就绪态

  资源分配到位，等待的时间发生(被动行为)

  

注意： 不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态 。

------

### 进程控制

进程控制就是实现进程状态转换。

用原语实现进程控制。原语的特点是执行期间**不允许中断**，具有**原子操作**。

原语的原子操作特性通过**关/开中断**来实现

原语时一种特殊的程序

#### 进程的创建

- 创建原语

  - 申请空白PCB
  - 为新进程分配所需资源
  - 初始化PCB
  - 将PCB插入就绪队列

- 引起进程创建事件

  - 用户登陆

    分时系统中，用户登陆成功，系统会为其建立一个新的进程

  - 作业调度

    多道批处理系统中，有新的作业放入内存时，会为其创建一个新的进程

  - 提供服务

    用户向操作系统提出某些请求时，会新建一个进程处理该请求

  - 应用请求

    由用户进程主动请求创建一个子进程



#### 进程的终止

-  撤销原语
  - 从PCB集合中找到终止进程的PCB
  - 若进程正在运行，立即剥夺CPU，将CPU分配给其它进程
  - 终止其所有子进程
  - 将该进程拥有的所有资源归还给父进程或操作系统
  - 删除PCB
- 引起进程终止的事件
  - 正常结束
  - 异常结束
  - 外界干预



#### 进程的阻塞

- 阻塞原语
  - 找到要阻塞的进程对应的PCB
  - 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行
  - 将PCB插入相应事件的等待队列
- 引起进程阻塞的事件
  - 需要等待系统分配某种资源
  - 需要等待互相合作的其它进程完成工作



#### 进程的唤醒

- 唤醒原语
  - 在事件等待队列中找到PCB
  - 将PCB从等待队列移除，设置进程为就绪态
  - 将PCB插入就绪队列，等待被调度
- 引起进程唤醒的事件
  - 等待的事件发生



#### 进程的切换

- 切换原语
  - 将运行环境信息存入PCB
  - PCB移入相应队列
  - 选择另一个进程执行，并更新其PCB
  - 根据PCB恢复新进程所需的运行环境
- 引起进程切换的事件
  - 当前进程时间片到
  - 有更高优先级的进程到达
  - 当前进程主动阻塞
  - 当前进程终止



------

### 进程通信

各进程拥有的内存地址空间**相互独立**。

为了保证安全，一个进程**不能直接访问**另一个进程的地址空间。

必须通过操作系统提供的方法进行通信



**进程通信**

- 共享存储
- 消息传递
- 管道通信



#### 共享存储

![WeChat25190c0ee4677886075dd4b53d7d5e8f.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gniot2j49dj311q0js7eu.jpg)

两个进程对共享空间的**访问**必须是**互斥**的(互斥访问通过操作系统提供的同步实现)

操作系统只负责提供共享空间和同步互斥工具(如P、V操作)



- 基于数据结构的共享

  比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种**低级通信**方式。

- 基于存储区的共享

  在内存中划出一块共享储存区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种**高级通信**方式。



#### 管道通信

![WeChatc0a5d4de8652a44c1d3263baa80bd1db.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnip0j9yx6j319s04qjxr.jpg)

“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。



1. 管道只能采用**半双工通信**，某一时间段内只能实现单向的传输。如果要实现**双向同时通信，则需要设置两个管道**。
2. 各进程需要**互斥**地访问管道。
3. 数据以字节流的形式写入管道，当**管道写满**时，**写进程**的write()系统调用将被**阻塞**，等待读进程将数据取走。当读进程将数据全部取走后，**管道变空**，此时**读进程**的read()系统调用将**被阻塞**。
4. 如果**没写满，就不允许读**。如果**没读空，就不允许写**。
5. 数据一旦被读出，就从管道中被抛弃，这意味着**读进程最多只能有一个**，否则可能会有读错数据的情况。



#### 消息传递

进程间的数据交换以**格式化的消息**(Message)为单位。进程通过操作系统提供的"发生消息/接收消息"两个**原语**进行数据交换。

![WeChat08f2e160ee3ff0e4ee83e7174f8ea6e7.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnipcufafjj30ra09eh0g.jpg)



- 直接通信方式

  消息直接挂在接收进程的消息缓冲队列上

  <img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnipfzmk9tj30k00d0aib.jpg" alt="WeChatf21f6deea963a261e089694852bbe961.png" style="zoom: 50%;" />

- 间接通信方式

  消息要先发送到中间实体中

  <img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnipictqr4j30rq094guq.jpg" alt="WeChat0b0f401850d9f3282bdeedd8a147b5d6.png" style="zoom: 50%;" />



------

### 线程

线程是一个**基本的CPU执行单元**，也是**程序执行流的最小单位**。

引入线程后，进程只作为**除CPU之外**的系统资源分配单元(打印机、内存地址空间等都是分配给进程的)。



#### 带来的变化

- 资源分配、调度
  - 传统进程机制中，进程是资源分配、调度的基本单位
  - 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
- 并发性
  - 传统进程机制中，只能进程间并发
  - 引入线程后，各线程间也能并发，提升了并发度
- 系统开销
  - 传统的进程间并发，需要切换进程的运行环境，系统开销很大
  - 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小
  - 引入线程后，并发所带来的系统开销减小



#### 线程的属性

- 线程是处理机调度的单位
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都有一个线程ID、线程控制块(TCB)
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间共享进程资源
- 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程的线程，系统开销很小
- 切换进程，系统开销很大



#### 线程的实现方式



- 用户级线程(User-Level Thread, ULT)

  用户线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责(包括线程切换)

  用户级线程中，线程切换可以在用户态下完成，无需操作系统干预。

  用户线程对用户不透明，对操作系统透明。

  ![WeChatd6dd2edb38ff6bf7c730724c8efa0dde.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqdv2c8dj30m20jmn76.jpg)

  

- 内核级线程(Kernel-Level Thread，KLT，又称"内核支持的线程")

  <img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqkztdn0j30ls0kodtb.jpg" alt="WeChatd4cb7c837b738f4978957a0d2a33cc9e.png" style="zoom:50%;" />

  内核级线程的**管理工作**由操作**系统内核**完成。线程调度、切换等工作都由内核负责，因此**内核级线程的切换**必须在**核心态**下才能完成。

  内核级线程是只有操作系统才能看到的线程。



在支持用户级线程和内核级的系统中，可以采用二者组合的方式：将n个用户级线程映射到m个内核级线程上(n>=m)

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqoegeraj30mq0lctnz.jpg" alt="WeChatcb6f7215e787ac34c73131d211c048ba.png" style="zoom:50%;" />

**重点**

操作系统只“看得见”内核级线程，因此只有**内核级线程才是处理机分配的单位**。



#### 多线程模型



##### 多对一模型

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqrql2o8j30mi0lc14x.jpg" alt="WeChat6c8d489393ec470ce7f546300260404e.png" style="zoom:50%;" />

多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被组设，并发度不高。多个线程**不可**在多核处理机上**并行**运行。



##### 一对一模型

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqw0herwj30o20le16s.jpg" alt="WeChat50c878add5cd1263d8cb814de119e5ac.png" style="zoom:50%;" />

一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。

缺点：一个用户进程占用多个内核级进程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。



##### 多对多模型

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnir0cae7qj30mm0lik7l.jpg" alt="WeChat2760e4681983ecdb5d4ad1d55262f473.png" style="zoom:50%;" />

n用户及线程映射到m个内核级线程(n>=m)。每个用户进程对应m个内核级线程。

优点：克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。



------

## 调度

### 处理机调度概念、层次

